// Main program to solve Sudoku puzzle given 3 difficulties, an inputed grid from file or custom grid of various sizes
//Code by Aiden Tarpinian and Josie Nelson
// inspired by "Comparison Analysis of Breadth First Search and Depth Limited Search Algorithms in Sudoku Game"
// by Tirsa Ninia Lina and Matheus Supriyanto Rumetna
// https://www.researchgate.net/publication/358642884_Comparison_Analysis_of_Breadth_First_Search_and_Depth_Limited_Search_Algorithms_in_Sudoku_Game

// imports
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // read in file of three grids
        try (BufferedReader reader = new BufferedReader(new FileReader("src/gridsforsudoku.txt"))) {
            int[][] easyGrid = readGrid(reader);   // Read Easy grid
            int[][] mediumGrid = readGrid(reader); // Read Medium grid
            int[][] hardGrid = readGrid(reader);   // Read Hard grid

            // solve+time easy grid with BFS and DLS
            System.out.println("==================================\nEASY GRID:\n");
            solveAndTimeGrid("Easy", easyGrid);

            // solve+time medium grid with BFS and DLS
            System.out.println("==================================\nMEDIUM GRID:\n");
            solveAndTimeGrid("Medium", mediumGrid);

            /// solve+time hard grid with BFS and DLS
            System.out.println("==================================\nHARD GRID:\n");
            solveAndTimeGrid("Hard", hardGrid);

            // create and solve a custom grid !
            int[][] customGrid = createCustomGrid(9); // put the size of the custom grid here! it will turn it into a square
            System.out.println("\nCUSTOM GRID:\n");
            solveAndTimeGrid("Custom", customGrid);

        } catch (IOException e) {
            System.out.println("Error reading the file: " + e.getMessage());
        }
    }

    // helper method to solve and print results for any grid
    private static void solveAndTimeGrid(String difficulty, int[][] grid) {
        // solve with BFS and time in nanoseconds
        long bfsStartTime = System.nanoTime();
        SudokuGraph bfsGraph = new SudokuGraph(grid);
        SudokuBFS bfsSolver = new SudokuBFS();
        boolean bfsSolved = bfsSolver.solve(bfsGraph);
        long bfsEndTime = System.nanoTime();
        if (bfsSolved) {
            System.out.println(difficulty + " grid solved with BFS in " + (bfsEndTime - bfsStartTime) + " ns.\n");
        } else {
            System.out.println(difficulty + " grid BFS failed.\n");
        }

        // solve with DLS and time in nanoseconds
        long dlsStartTime = System.nanoTime();
        SudokuGraph dlsGraph = new SudokuGraph(grid);
        SudokuDLS dlsSolver = new SudokuDLS();
        boolean dlsSolved = dlsSolver.solve(dlsGraph, grid.length * grid.length); // Depth limit = total number of cells
        long dlsEndTime = System.nanoTime();
        if (dlsSolved) {
            System.out.println(difficulty + " grid solved with DLS in " + (dlsEndTime - dlsStartTime) + " ns.\n");
        } else {
            System.out.println(difficulty + " grid DLS failed.\n");
        }
    }


    // helper method to read a grid dynamically based on the size in the text file
    private static int[][] readGrid(BufferedReader reader) throws IOException {
        String line;

        // skip difficulty level lines in file
        while ((line = reader.readLine()) != null && (line.equalsIgnoreCase("easy") || line.equalsIgnoreCase("medium") || line.equalsIgnoreCase("hard"))) {
        }

        // read the first valid line to set the grid size
        if (line == null || line.trim().isEmpty()) {
            throw new IllegalArgumentException("Invalid grid format: No valid rows found.");
        }

        int gridSize = line.length();  // The len of the first line determines the grid size (as square)
        int[][] grid = new int[gridSize][gridSize];

        // read the grid!- thank you chat gpt for the help
        int row = 0;
        do {
            line = line.trim();  // trim whitespace
            if (line.length() == gridSize) {
                for (int col = 0; col < gridSize; col++) {
                    grid[row][col] = Character.getNumericValue(line.charAt(col));  // make each character a number
                }
                row++; // go through each row
            } else {
                System.out.println("Skipping invalid line: '" + line + "'");
            }
        } while ((line = reader.readLine()) != null && row < gridSize);

        // in case grid doesn't match the expected dimensions
        if (row != gridSize) {
            throw new IllegalArgumentException("Grid dimensions do not match: Expected " + gridSize + "x" + gridSize + " grid.");
        }

        return grid;
    }

    // helper method to create a custom grid of a given size - thanks chat gpt
    private static int[][] createCustomGrid(int size) {
        int[][] grid = new int[size][size];
        // initialize grid with values on subgrid diagonals, empty elsewhere
        int subGridSize = (int) Math.sqrt(size);
        for (int i = 0; i < size; i += subGridSize) {
            for (int j = 0; j < subGridSize; j++) {
                for (int k = 0; k < subGridSize; k++) {
                    grid[i + j][i + k] = (j * subGridSize + k + 1) % size + 1;
                }
            }
        }
        return grid;
    }
}

// CITATIONS:
// chatgpt.com
// https://puzzling.stackexchange.com/questions/67789/examples-of-sudokus-with-two-solutions
// https://www.sudokuonline.io/kids/numbers-6-6
// https://www.sudoku9x9.com
